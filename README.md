# Buffer-overflow-attack
Код был скомпилирован gcc в debug режиме,под x64 битную систему.
Атака переполнением буфера.
Данный код является демонстрацией анатомии атаки переполнением буфера,по сути в myfunc() мы вызвали функцию echer(),которая по идее не должна была вызываться,данная атака реализуется заменой ret-addr в стеке на аддрес нашей зловредной функции.
Хронология:
На 11 строке мы вызываем функцию myfunc(),если она выполняется неуспехом(тоесть нам не удается изменить ret addr),то на экран выводится соответсвенное сообщение(строка 12)
В вызванной функции на строке 19 мы создаем массив с одним элементом,после этого собственно и происходит сама атака,мы обращаемся к m[3] тоесть 3 элементу массива которого по идее не должно существовать,однако для того чтобы понять что происходит далее сначала нужно принять что m[0] = это единсвенный(4 байтный тоесть int) элемент массива,m[1] = следующие 4 байта за массивом(то есть половина ebp он же frame pointer),m[2] = (вторая половина ebp),m[3] = первая половина ret-addr.
Теперь собственно складываем паззл,примим что мы находимся в x64 битной системе,тоесть все обязательные элементы call stack-а((вообще зависит от соглашения вызова) но в самом простом случае это ebp и ret addr) 8 байтные,и теперь когда мы записываем аддрес нашей функции в несуществующий 3 элемент массива мы по сути пишем в старшие 4 байта 8 байтного ret-addr,тем самым подменяя адрес возврата на свой.
После того как функция myfunc() выполняется она вместо того чтобы передать управление main() переходит именно по тому аддресу который мы записали в ret addr,в нашем случае это функция echer() которая сигнализирует нам об успехе ее выполнения,после того как функция echer() выполняется ей некуда возвращать значение ведь у нас нету кадра функции echer() в стеке а соответсвенно нету и своего ret-addr.

Данный код лишь пример для демонстрации атаки перепонением буфера,ведь если подумать то в реальном мире у нас не будет доступа к исходникам программы и мы не сможем ничего сделать(только если не являемся разработчиком :D ),поэтому я приведу в пример историю со взломом который основывался именно на этой атаке.
Итак,както вечером в 1988 году попивая чаек и как всегда читая документацию по языку C(на котором в то время были написаны практически все программы),некий Моррис присмотрелся к функции gets(),в которую передовался лишь один параметр а именно буффер и которая считывала со стандартного ввода в этот самый буфер,однако было бы все прекрастно и хорошо но буффер который передавался gets()-у был ограничен и если скажем в нее был передан буффер который соответсвовал размеру (на пример) 128 байт то считав 128 символов,функция начала бы записывать то что пользователь ввел с клавиатуры сначало в ebp а потом и в ret-addr,и тут Моррисс понял что он обнаружил значительный баг,после этого он принялся релизовывать вирус основанный именно на атаке переполнением буффера,и был этим вирусом "Червь Морриса",он основывался на том чтобы передать в системную программу finger которая работала со строкой запрашивая nickname пользователя и считывавшая его в 512-байтный буффер,через стандартный ввод 512 байт произвольных символов,(пускай у нас будет x32 битная система) еще 4 байта произвольных символов(ebp он же frame pointer),и собственно  4 байта адреса нашего вредоносного кода который запишится вместо ret-addr,далее наш вредоносный код выполняется от имени системной программы тоесть finger-а,тоесть он выполняется в kernel-space и для него нету никаких ограничений,и теперь вопрос зачем столько мароки если можно было просто написать вредоностный код который бы исполнился,а ответ крайне прост....он бы не исполнился поскольку он бы запустился в user-space и исполнение первой же запрещенной машинной инструкции вызвало бы прерывание и kernel собственно бы убил наш процесс,в случае же с червем моррисса,вредоностный код выполнялся от имени системной программы (поскольку это было в unix то просто под root).
Вот и конец истории,а мораль крайне проста,контроллируй обращение к индексам массива(что разработчики C и сделали в следующем релизе)!

Статья от меня для меня.
